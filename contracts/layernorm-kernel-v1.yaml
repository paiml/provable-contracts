metadata:
  version: "1.0.0"
  created: "2026-02-18"
  author: "PAIML Engineering"
  description: "LayerNorm kernel â€” layer normalization with affine transform"
  references:
    - "Ba et al. (2016) Layer Normalization"
    - "Ioffe & Szegedy (2015) Batch Normalization"

equations:
  layernorm:
    formula: "LN(x)_i = gamma_i * (x_i - mu) / sqrt(sigma^2 + eps) + beta_i"
    domain: "x in R^d, gamma in R^d, beta in R^d, eps > 0"
    codomain: "LN(x) in R^d"
    invariants:
      - "mean(LN(x)) = mean(beta) when gamma = 1 (centering)"
      - "var(LN(x)) = 1 when gamma = 1, beta = 0 (standardization)"
      - "LN is invariant to input shift: LN(x + c) = LN(x)"
  statistics:
    formula: "mu = (1/d) * sum(x_i), sigma^2 = (1/d) * sum((x_i - mu)^2)"
    domain: "x in R^d, d >= 1"
    codomain: "mu in R, sigma^2 in R_>=0"
    invariants:
      - "sigma^2 >= 0 (non-negative variance)"
      - "sigma^2 = 0 iff x is constant"

proof_obligations:
  - type: invariant
    property: "Centering"
    formal: "|mean(LN(x)) - mean(beta)| < eps when gamma = 1"
    tolerance: 1.0e-5
    applies_to: all
  - type: invariant
    property: "Standardization"
    formal: "|var(LN(x)) - 1.0| < eps when gamma = 1, beta = 0"
    tolerance: 1.0e-5
    applies_to: all
  - type: bound
    property: "Denominator strictly positive"
    formal: "sqrt(sigma^2 + eps) > 0 when eps > 0"
    applies_to: all
  - type: equivalence
    property: "SIMD matches scalar within ULP"
    tolerance: 8.0
    applies_to: simd
  - type: idempotency
    property: "Idempotent under identity affine"
    formal: "|LN(LN(x)) - LN(x)| < eps when gamma = 1, beta = 0"
    tolerance: 1.0e-5
    applies_to: all
  - type: invariant
    property: "Shift invariance"
    formal: "|LN(x + c) - LN(x)| < eps for any scalar c"
    tolerance: 1.0e-6
    applies_to: all

kernel_structure:
  phases:
    - name: compute_mean
      description: "Compute mu = mean(x)"
      invariant: "min(x) <= mu <= max(x)"
    - name: compute_variance
      description: "Compute sigma^2 = var(x)"
      invariant: "sigma^2 >= 0"
    - name: normalize
      description: "Compute (x - mu) / sqrt(sigma^2 + eps)"
      invariant: "denominator > 0"
    - name: affine_transform
      description: "Apply gamma * normalized + beta"
      invariant: "output dimension equals d"

simd_dispatch:
  layernorm:
    scalar: layernorm_scalar
    avx2: layernorm_avx2
    ptx: layernorm_ptx

enforcement:
  centering:
    description: "Output mean must equal mean(beta) when gamma=1"
    check: "contract_tests::FALSIFY-LN-001"
    severity: "ERROR"
  standardization:
    description: "Output variance must equal 1 when gamma=1, beta=0"
    check: "contract_tests::FALSIFY-LN-002"
    severity: "ERROR"

falsification_tests:
  - id: FALSIFY-LN-001
    rule: "Centering"
    prediction: "|mean(LN(x)) - mean(beta)| < 1e-5 with gamma=1"
    test: "proptest with random x, random beta, gamma=1, dim 1..128"
    if_fails: "Mean subtraction or affine transform incorrect"
  - id: FALSIFY-LN-002
    rule: "Standardization"
    prediction: "|var(LN(x)) - 1.0| < 1e-5 with gamma=1, beta=0"
    test: "proptest with random non-constant x, dim 1..128"
    if_fails: "Variance normalization incorrect"
  - id: FALSIFY-LN-003
    rule: "Denominator safety"
    prediction: "No NaN/Inf in output for any finite input when eps > 0"
    test: "proptest with extreme values near f32::MIN/MAX"
    if_fails: "Epsilon not added before sqrt, or overflow in variance"
  - id: FALSIFY-LN-004
    rule: "SIMD equivalence"
    prediction: "|layernorm_avx2(x) - layernorm_scalar(x)| < 8 ULP"
    test: "proptest comparing scalar vs SIMD output"
    if_fails: "SIMD reduction order differs from scalar"
  - id: FALSIFY-LN-005
    rule: "Idempotency"
    prediction: "|LN(LN(x)) - LN(x)| < 1e-5 with gamma=1, beta=0"
    test: "proptest applying LN twice to random vectors"
    if_fails: "Second pass re-normalizes non-trivially"
  - id: FALSIFY-LN-006
    rule: "Shift invariance"
    prediction: "|LN(x + c) - LN(x)| < 1e-6 for random scalar c"
    test: "proptest with random x and shift c in [-1000, 1000]"
    if_fails: "Mean subtraction not canceling shift"
  - id: FALSIFY-LN-007
    rule: "Boundary - constant input"
    prediction: "LN([c,c,...,c]) = [beta_1,...,beta_d] when gamma=1"
    test: "proptest with constant vectors"
    if_fails: "Division by near-zero variance not handled"

kani_harnesses:
  - id: KANI-LN-001
    obligation: LN-INV-001
    property: "LayerNorm centers output for small vectors"
    bound: 8
    strategy: stub_float
    solver: cadical
    harness: verify_layernorm_centering
  - id: KANI-LN-002
    obligation: LN-INV-002
    property: "LayerNorm standardizes output for small vectors"
    bound: 8
    strategy: stub_float
    solver: cadical
    harness: verify_layernorm_standardization
  - id: KANI-LN-003
    obligation: LN-BND-001
    property: "Denominator always positive with eps > 0"
    bound: 8
    strategy: stub_float
    solver: cadical
    harness: verify_layernorm_denominator_positive

qa_gate:
  id: F-LN-001
  name: "LayerNorm Contract"
  description: "Layer normalization with affine transform quality gate"
  checks:
    - "centering"
    - "standardization"
    - "denominator_safety"
    - "simd_equivalence"
    - "idempotency"
  pass_criteria: "All 7 falsification tests pass + Kani harnesses verify"
  falsification: "Remove epsilon from denominator sqrt"
