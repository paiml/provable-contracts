metadata:
  version: "1.0.0"
  created: "2026-02-20"
  author: "PAIML Engineering"
  description: "Qwen3-8B end-to-end verification — composing all kernel contracts into a complete model proof"
  references:
    - "Qwen3 Technical Report — full model architecture"
    - "Vaswani et al. (2017) Attention Is All You Need"
    - "Su et al. (2021) RoFormer: Enhanced Transformer with Rotary Position Embedding"
  depends_on:
    - "qwen3-shapes-v1"
    - "inference-pipeline-v1"
    - "embedding-algebra-v1"
    - "attention-scaling-v1"
    - "kv-cache-sizing-v1"

equations:
  model_parameter_count:
    formula: "P = V*d + L*(d_attn + d_ffn + d_norm) + d_final"
    domain: "V=151936, d=4096, L=36, d_attn/d_ffn/d_norm=per-layer params"
    invariants:
      - "Total ≈ 8.19B for Qwen3-8B"
      - "Embedding: 151936 * 4096 ≈ 622.3M"
      - "Per-layer attention: 2*(4096^2) + 2*(1024*4096) ≈ 41.9M"
      - "Per-layer FFN: 3 * 4096 * 12288 ≈ 151.0M"
      - "Per-layer cost linear in d^2"
  flops_per_token:
    formula: "F ≈ 2*P (forward pass) for dense compute"
    domain: "Approximate FLOPs per token for autoregressive generation"
    invariants:
      - "Linear in P"
      - "Attention FLOP component is O(seq_len * d)"
      - "GQA reduces KV computation by factor n_h/n_kv = 4"
  memory_breakdown:
    formula: "M = M_weights + M_kv + M_activations"
    domain: "Total GPU memory during inference"
    invariants:
      - "M_weights depends on quantization (Q4K < Q6K < F16 < F32)"
      - "M_kv grows linearly with sequence length"
      - "M_kv per layer = 2 * n_kv * d_k * seq_len * dtype_bytes"
      - "M_activations bounded by batch_size * seq_len * d"
  throughput_model:
    formula: "tok/s = min(bandwidth / bytes_per_token, compute / flops_per_token)"
    domain: "Roofline-limited throughput"
    invariants:
      - "Memory-bound for small batch (typical inference)"
      - "Compute-bound for large batch or long prefill"
  verification_ladder:
    formula: "coverage(contract_set) = verified_obligations / total_obligations"
    domain: "Fraction of proof obligations with passing tests or Kani proofs"
    invariants:
      - "coverage in [0, 1]"
      - "coverage = 1 means all obligations verified"
      - "Each layer adds: attention + FFN + 2*RMSNorm obligations"
  contract_composition:
    formula: "model_contract = compose(embedding, L * block, final_norm, unembed)"
    domain: "Full model as composition of verified components"
    invariants:
      - "Each component independently verified"
      - "Composition preserves shape invariants"
      - "Residual stream provides compositional proof structure"
      - "36 identical decoder blocks (no hybrid layers)"

proof_obligations:
  - type: invariant
    property: "Parameter count matches architecture"
    formal: "P(Qwen3-8B) in [8.0B, 8.4B]"
    applies_to: all
  - type: bound
    property: "FLOPs bounded by 2P"
    formal: "F <= 2 * P + O(seq_len * d * L)"
    applies_to: all
  - type: ordering
    property: "Quantization memory ordering"
    formal: "M(Q4K) < M(Q6K) < M(F16) < M(F32)"
    applies_to: all
  - type: monotonicity
    property: "Throughput increases with bandwidth"
    formal: "bw1 < bw2 -> tok_s(bw1) <= tok_s(bw2)"
    applies_to: all
  - type: bound
    property: "Verification coverage at 100%"
    formal: "coverage(qwen3_contracts) = 1.0"
    applies_to: all
  - type: invariant
    property: "Compositional proof structure"
    formal: "for all l: shape(block_l(x)) = shape(x)"
    applies_to: all
  - type: conservation
    property: "End-to-end shape: tokens in -> logits out"
    formal: "shape(model(tokens)) = [seq_len, V]"
    tolerance: 0.0
    applies_to: all

falsification_tests:
  - id: FALSIFY-QW3E-001
    rule: "Parameter count"
    prediction: "Total params ≈ 8.19B"
    test: "Deterministic: sum all parameter shapes"
    if_fails: "Architecture config mismatch"
  - id: FALSIFY-QW3E-002
    rule: "FLOPs estimate"
    prediction: "2P FLOPs per forward token"
    test: "Deterministic with Qwen3-8B constants"
    if_fails: "Missing layer in FLOP count"
  - id: FALSIFY-QW3E-003
    rule: "Memory ordering"
    prediction: "Q4K < Q6K < F16 < F32 memory"
    test: "proptest with random tensor dimensions"
    if_fails: "Quantization byte formula wrong"
  - id: FALSIFY-QW3E-004
    rule: "Throughput roofline"
    prediction: "tok/s bounded by bandwidth and compute"
    test: "proptest with random hardware specs"
    if_fails: "Roofline formula error"
  - id: FALSIFY-QW3E-005
    rule: "Coverage completeness"
    prediction: "All obligations have test or proof"
    test: "pv coverage --binding check"
    if_fails: "Missing obligation coverage"
  - id: FALSIFY-QW3E-006
    rule: "Compositional proof structure"
    prediction: "Each block preserves shape: shape(block_l(x)) = shape(x)"
    test: "proptest: verify shape(block(x)) = shape(x) for random blocks"
    if_fails: "Block l breaks shape invariant"
  - id: FALSIFY-QW3E-007
    rule: "End-to-end shape conservation"
    prediction: "tokens -> [seq_len, 4096] -> ... -> [seq_len, 151936]"
    test: "proptest: trace shapes through mock pipeline"
    if_fails: "Shape break in layer composition"

kani_harnesses:
  - id: KANI-QW3E-001
    obligation: QW3E-INV-001
    property: "Parameter count within expected range"
    bound: 1
    strategy: exhaustive
    solver: cadical
    harness: verify_qwen3_parameter_count
  - id: KANI-QW3E-002
    obligation: QW3E-ORD-001
    property: "Quantization memory ordering"
    bound: 4
    strategy: bounded_int
    harness: verify_qwen3_quant_ordering

qa_gate:
  id: F-QW3E-001
  name: "Qwen3 End-to-End Verification"
  description: "Full model verification composition quality gate"
  checks:
    - "model_parameter_count"
    - "flops_per_token"
    - "memory_breakdown"
    - "throughput_model"
    - "verification_ladder"
    - "contract_composition"
  pass_criteria: "All 7 falsification tests pass + 100% obligation coverage"
  falsification: "Remove one layer from parameter count to break total"
